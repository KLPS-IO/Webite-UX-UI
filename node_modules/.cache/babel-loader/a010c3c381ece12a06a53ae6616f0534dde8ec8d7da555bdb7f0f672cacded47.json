{"ast":null,"code":"var _s = $RefreshSig$();\n// To use gsap with locomotive scroll, we have to use scroller proxy provided by gsap\nimport gsap from \"gsap\";\nimport ScrollTrigger from \"gsap/ScrollTrigger\";\nimport { useEffect } from \"react\";\nimport { useLocomotiveScroll } from \"react-locomotive-scroll\";\nconst ScrollTriggerProxy = () => {\n  _s();\n  // first let's get instance of locomotive scroll\n\n  const {\n    scroll\n  } = useLocomotiveScroll();\n  // Register scroll trigger plugin\n  gsap.registerPlugin(ScrollTrigger);\n  useEffect(() => {\n    if (scroll) {\n      const element = scroll === null || scroll === void 0 ? void 0 : scroll.el; // locomotive scrolling element, in our case it's app (main)\n\n      scroll.on(\"scroll\", ScrollTrigger.update); // on scroll of locomotive, update scrolltrigger\n\n      //  let's use scroller proxy\n      ScrollTrigger.scrollerProxy(element, {\n        scrollTop(value) {\n          return arguments.length ? scroll.scrollTo(value, 0, 0) : scroll.scroll.instance.scroll.y;\n        },\n        // we don't have to define a scrollLeft because we're only scrolling vertically.\n        getBoundingClientRect() {\n          return {\n            top: 0,\n            left: 0,\n            width: window.innerWidth,\n            height: window.innerHeight\n          };\n        },\n        // LocomotiveScroll handles things completely differently on mobile devices - it doesn't even transform the container at all! So to get the correct behavior and avoid jitters, we should pin things with position: fixed on mobile. We sense it by checking to see if there's a transform applied to the container (the LocomotiveScroll-controlled element).\n        pinType: element.style.transform ? \"transform\" : \"fixed\"\n      });\n    }\n    return () => {\n      ScrollTrigger.addEventListener(\"refresh\", () => scroll === null || scroll === void 0 ? void 0 : scroll.update());\n      ScrollTrigger.refresh();\n    };\n  }, [scroll]);\n  return null;\n};\n_s(ScrollTriggerProxy, \"IwiEG3ynQwo6uTnjwSbeeNjIY+M=\", false, function () {\n  return [useLocomotiveScroll];\n});\n_c = ScrollTriggerProxy;\nexport default ScrollTriggerProxy;\nvar _c;\n$RefreshReg$(_c, \"ScrollTriggerProxy\");","map":{"version":3,"names":["gsap","ScrollTrigger","useEffect","useLocomotiveScroll","ScrollTriggerProxy","_s","scroll","registerPlugin","element","el","on","update","scrollerProxy","scrollTop","value","arguments","length","scrollTo","instance","y","getBoundingClientRect","top","left","width","window","innerWidth","height","innerHeight","pinType","style","transform","addEventListener","refresh","_c","$RefreshReg$"],"sources":["/Users/emmamendez/Source/Klippies/KLPS Website/wibe-studio-product-files/src/components/ScrollTriggerProxy.js"],"sourcesContent":["// To use gsap with locomotive scroll, we have to use scroller proxy provided by gsap\r\nimport gsap from \"gsap\";\r\nimport ScrollTrigger from \"gsap/ScrollTrigger\";\r\nimport { useEffect } from \"react\";\r\nimport { useLocomotiveScroll } from \"react-locomotive-scroll\";\r\n\r\nconst ScrollTriggerProxy = () => {\r\n  // first let's get instance of locomotive scroll\r\n\r\n  const { scroll } = useLocomotiveScroll();\r\n  // Register scroll trigger plugin\r\n  gsap.registerPlugin(ScrollTrigger);\r\n\r\n  useEffect(() => {\r\n    if (scroll) {\r\n      const element = scroll?.el; // locomotive scrolling element, in our case it's app (main)\r\n\r\n      scroll.on(\"scroll\", ScrollTrigger.update); // on scroll of locomotive, update scrolltrigger\r\n\r\n      //  let's use scroller proxy\r\n      ScrollTrigger.scrollerProxy(element, {\r\n        scrollTop(value) {\r\n          return arguments.length\r\n            ? scroll.scrollTo(value, 0, 0)\r\n            : scroll.scroll.instance.scroll.y;\r\n        }, // we don't have to define a scrollLeft because we're only scrolling vertically.\r\n        getBoundingClientRect() {\r\n          return {\r\n            top: 0,\r\n            left: 0,\r\n            width: window.innerWidth,\r\n            height: window.innerHeight,\r\n          };\r\n        },\r\n        // LocomotiveScroll handles things completely differently on mobile devices - it doesn't even transform the container at all! So to get the correct behavior and avoid jitters, we should pin things with position: fixed on mobile. We sense it by checking to see if there's a transform applied to the container (the LocomotiveScroll-controlled element).\r\n        pinType: element.style.transform ? \"transform\" : \"fixed\",\r\n      });\r\n    }\r\n\r\n    return () => {\r\n      ScrollTrigger.addEventListener(\"refresh\", () => scroll?.update());\r\n      ScrollTrigger.refresh();\r\n    };\r\n  }, [scroll]);\r\n\r\n  return null;\r\n};\r\n\r\nexport default ScrollTriggerProxy;\r\n"],"mappings":";AAAA;AACA,OAAOA,IAAI,MAAM,MAAM;AACvB,OAAOC,aAAa,MAAM,oBAAoB;AAC9C,SAASC,SAAS,QAAQ,OAAO;AACjC,SAASC,mBAAmB,QAAQ,yBAAyB;AAE7D,MAAMC,kBAAkB,GAAGA,CAAA,KAAM;EAAAC,EAAA;EAC/B;;EAEA,MAAM;IAAEC;EAAO,CAAC,GAAGH,mBAAmB,CAAC,CAAC;EACxC;EACAH,IAAI,CAACO,cAAc,CAACN,aAAa,CAAC;EAElCC,SAAS,CAAC,MAAM;IACd,IAAII,MAAM,EAAE;MACV,MAAME,OAAO,GAAGF,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAEG,EAAE,CAAC,CAAC;;MAE5BH,MAAM,CAACI,EAAE,CAAC,QAAQ,EAAET,aAAa,CAACU,MAAM,CAAC,CAAC,CAAC;;MAE3C;MACAV,aAAa,CAACW,aAAa,CAACJ,OAAO,EAAE;QACnCK,SAASA,CAACC,KAAK,EAAE;UACf,OAAOC,SAAS,CAACC,MAAM,GACnBV,MAAM,CAACW,QAAQ,CAACH,KAAK,EAAE,CAAC,EAAE,CAAC,CAAC,GAC5BR,MAAM,CAACA,MAAM,CAACY,QAAQ,CAACZ,MAAM,CAACa,CAAC;QACrC,CAAC;QAAE;QACHC,qBAAqBA,CAAA,EAAG;UACtB,OAAO;YACLC,GAAG,EAAE,CAAC;YACNC,IAAI,EAAE,CAAC;YACPC,KAAK,EAAEC,MAAM,CAACC,UAAU;YACxBC,MAAM,EAAEF,MAAM,CAACG;UACjB,CAAC;QACH,CAAC;QACD;QACAC,OAAO,EAAEpB,OAAO,CAACqB,KAAK,CAACC,SAAS,GAAG,WAAW,GAAG;MACnD,CAAC,CAAC;IACJ;IAEA,OAAO,MAAM;MACX7B,aAAa,CAAC8B,gBAAgB,CAAC,SAAS,EAAE,MAAMzB,MAAM,aAANA,MAAM,uBAANA,MAAM,CAAEK,MAAM,CAAC,CAAC,CAAC;MACjEV,aAAa,CAAC+B,OAAO,CAAC,CAAC;IACzB,CAAC;EACH,CAAC,EAAE,CAAC1B,MAAM,CAAC,CAAC;EAEZ,OAAO,IAAI;AACb,CAAC;AAACD,EAAA,CAxCID,kBAAkB;EAAA,QAGHD,mBAAmB;AAAA;AAAA8B,EAAA,GAHlC7B,kBAAkB;AA0CxB,eAAeA,kBAAkB;AAAC,IAAA6B,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"var _s = $RefreshSig$();\n\n// To use gsap with locomotive scroll, we have to use scroller proxy provided by gsap\nimport gsap from \"gsap\";\nimport ScrollTrigger from \"gsap/ScrollTrigger\";\nimport { useEffect } from \"react\";\nimport { useLocomotiveScroll } from \"react-locomotive-scroll\";\n\nconst ScrollTriggerProxy = () => {\n  _s();\n\n  // first let's get instance of locomotive scroll\n  const {\n    scroll\n  } = useLocomotiveScroll(); // Register scroll trigger plugin\n\n  gsap.registerPlugin(ScrollTrigger);\n  useEffect(() => {\n    if (scroll) {\n      const element = scroll === null || scroll === void 0 ? void 0 : scroll.el; // locomotive scrolling element, in our case it's app (main)\n\n      scroll.on(\"scroll\", ScrollTrigger.update); // on scroll of locomotive, update scrolltrigger\n      //  let's use scroller proxy\n\n      ScrollTrigger.scrollerProxy(element, {\n        scrollTop(value) {\n          return arguments.length ? scroll.scrollTo(value, 0, 0) : scroll.scroll.instance.scroll.y;\n        },\n\n        // we don't have to define a scrollLeft because we're only scrolling vertically.\n        getBoundingClientRect() {\n          return {\n            top: 0,\n            left: 0,\n            width: window.innerWidth,\n            height: window.innerHeight\n          };\n        },\n\n        // LocomotiveScroll handles things completely differently on mobile devices - it doesn't even transform the container at all! So to get the correct behavior and avoid jitters, we should pin things with position: fixed on mobile. We sense it by checking to see if there's a transform applied to the container (the LocomotiveScroll-controlled element).\n        pinType: element.style.transform ? \"transform\" : \"fixed\"\n      });\n    }\n\n    return () => {\n      ScrollTrigger.addEventListener(\"refresh\", () => scroll === null || scroll === void 0 ? void 0 : scroll.update());\n      ScrollTrigger.refresh();\n    };\n  }, [scroll]);\n  return null;\n};\n\n_s(ScrollTriggerProxy, \"IwiEG3ynQwo6uTnjwSbeeNjIY+M=\", false, function () {\n  return [useLocomotiveScroll];\n});\n\n_c = ScrollTriggerProxy;\nexport default ScrollTriggerProxy;\n\nvar _c;\n\n$RefreshReg$(_c, \"ScrollTriggerProxy\");","map":{"version":3,"sources":["/Users/emmamendez/Source/Klippies/KLPS Website/wibe-studio-product-files/src/components/ScrollTriggerProxy.js"],"names":["gsap","ScrollTrigger","useEffect","useLocomotiveScroll","ScrollTriggerProxy","scroll","registerPlugin","element","el","on","update","scrollerProxy","scrollTop","value","arguments","length","scrollTo","instance","y","getBoundingClientRect","top","left","width","window","innerWidth","height","innerHeight","pinType","style","transform","addEventListener","refresh"],"mappings":";;AAAA;AACA,OAAOA,IAAP,MAAiB,MAAjB;AACA,OAAOC,aAAP,MAA0B,oBAA1B;AACA,SAASC,SAAT,QAA0B,OAA1B;AACA,SAASC,mBAAT,QAAoC,yBAApC;;AAEA,MAAMC,kBAAkB,GAAG,MAAM;AAAA;;AAC/B;AAEA,QAAM;AAAEC,IAAAA;AAAF,MAAaF,mBAAmB,EAAtC,CAH+B,CAI/B;;AACAH,EAAAA,IAAI,CAACM,cAAL,CAAoBL,aAApB;AAEAC,EAAAA,SAAS,CAAC,MAAM;AACd,QAAIG,MAAJ,EAAY;AACV,YAAME,OAAO,GAAGF,MAAH,aAAGA,MAAH,uBAAGA,MAAM,CAAEG,EAAxB,CADU,CACkB;;AAE5BH,MAAAA,MAAM,CAACI,EAAP,CAAU,QAAV,EAAoBR,aAAa,CAACS,MAAlC,EAHU,CAGiC;AAE3C;;AACAT,MAAAA,aAAa,CAACU,aAAd,CAA4BJ,OAA5B,EAAqC;AACnCK,QAAAA,SAAS,CAACC,KAAD,EAAQ;AACf,iBAAOC,SAAS,CAACC,MAAV,GACHV,MAAM,CAACW,QAAP,CAAgBH,KAAhB,EAAuB,CAAvB,EAA0B,CAA1B,CADG,GAEHR,MAAM,CAACA,MAAP,CAAcY,QAAd,CAAuBZ,MAAvB,CAA8Ba,CAFlC;AAGD,SALkC;;AAKhC;AACHC,QAAAA,qBAAqB,GAAG;AACtB,iBAAO;AACLC,YAAAA,GAAG,EAAE,CADA;AAELC,YAAAA,IAAI,EAAE,CAFD;AAGLC,YAAAA,KAAK,EAAEC,MAAM,CAACC,UAHT;AAILC,YAAAA,MAAM,EAAEF,MAAM,CAACG;AAJV,WAAP;AAMD,SAbkC;;AAcnC;AACAC,QAAAA,OAAO,EAAEpB,OAAO,CAACqB,KAAR,CAAcC,SAAd,GAA0B,WAA1B,GAAwC;AAfd,OAArC;AAiBD;;AAED,WAAO,MAAM;AACX5B,MAAAA,aAAa,CAAC6B,gBAAd,CAA+B,SAA/B,EAA0C,MAAMzB,MAAN,aAAMA,MAAN,uBAAMA,MAAM,CAAEK,MAAR,EAAhD;AACAT,MAAAA,aAAa,CAAC8B,OAAd;AACD,KAHD;AAID,GA9BQ,EA8BN,CAAC1B,MAAD,CA9BM,CAAT;AAgCA,SAAO,IAAP;AACD,CAxCD;;GAAMD,kB;UAGeD,mB;;;KAHfC,kB;AA0CN,eAAeA,kBAAf","sourcesContent":["// To use gsap with locomotive scroll, we have to use scroller proxy provided by gsap\r\nimport gsap from \"gsap\";\r\nimport ScrollTrigger from \"gsap/ScrollTrigger\";\r\nimport { useEffect } from \"react\";\r\nimport { useLocomotiveScroll } from \"react-locomotive-scroll\";\r\n\r\nconst ScrollTriggerProxy = () => {\r\n  // first let's get instance of locomotive scroll\r\n\r\n  const { scroll } = useLocomotiveScroll();\r\n  // Register scroll trigger plugin\r\n  gsap.registerPlugin(ScrollTrigger);\r\n\r\n  useEffect(() => {\r\n    if (scroll) {\r\n      const element = scroll?.el; // locomotive scrolling element, in our case it's app (main)\r\n\r\n      scroll.on(\"scroll\", ScrollTrigger.update); // on scroll of locomotive, update scrolltrigger\r\n\r\n      //  let's use scroller proxy\r\n      ScrollTrigger.scrollerProxy(element, {\r\n        scrollTop(value) {\r\n          return arguments.length\r\n            ? scroll.scrollTo(value, 0, 0)\r\n            : scroll.scroll.instance.scroll.y;\r\n        }, // we don't have to define a scrollLeft because we're only scrolling vertically.\r\n        getBoundingClientRect() {\r\n          return {\r\n            top: 0,\r\n            left: 0,\r\n            width: window.innerWidth,\r\n            height: window.innerHeight,\r\n          };\r\n        },\r\n        // LocomotiveScroll handles things completely differently on mobile devices - it doesn't even transform the container at all! So to get the correct behavior and avoid jitters, we should pin things with position: fixed on mobile. We sense it by checking to see if there's a transform applied to the container (the LocomotiveScroll-controlled element).\r\n        pinType: element.style.transform ? \"transform\" : \"fixed\",\r\n      });\r\n    }\r\n\r\n    return () => {\r\n      ScrollTrigger.addEventListener(\"refresh\", () => scroll?.update());\r\n      ScrollTrigger.refresh();\r\n    };\r\n  }, [scroll]);\r\n\r\n  return null;\r\n};\r\n\r\nexport default ScrollTriggerProxy;\r\n"]},"metadata":{},"sourceType":"module"}